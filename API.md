# CTF Archive API

CTF 아카이브의 API의 명세와 조건, 참고사항 및 예외들을 정리해 작성한 문서입니다.

위 문장에서 '예외들'은 실제로 프로그램에서 예외를 던져야 한다는 의미로 쓴 것은 아닙니다. 주로 사용자가 잘못된 입력을 넣었을 때, 버그나 취약점이 발생할 수 있고 프로그래머가 자칫 넘기기 쉬울 수 있는 부분들을 뜻합니다. 별도의 처리를 하라고 명시되어 있지 않다면 따로 무언가를 하지 않는 것을 권장합니다.

만약 주어진 입력이 잘못된 쿼리라고 판단된 경우, HTTP 상태 코드는 400 Bad Request 여야 합니다. 또한 __각 엔드포인트에 명시된 값을 반환__ 하며, 쿼리를 실행하기 전, 파싱 도중에 즉시 응답을 완료하여야 합니다. 즉, 파싱 외의 추가적인 성능 소모가 없어야 합니다.

만약 주어진 입력이 존재하지 않는 요소를 참조한다고 판단된 경우, HTTP 상태 코드는 __404 Not Found__ 여야 합니다. 또한 __각 엔드포인트에 명시된 값을 반환__ 하며, 쿼리에 대한 결과를 만들기 전, 입력에 따른 요소를 가져오는 도중에 즉시 응답을 완료하여야 합니다. 즉, 파싱 및 값 참조 외에 추가적인 성능 소모가 없어야 합니다.

본 문서에서 산술 평균, 조화 평균, 절사 평균, 혹은 중위값 등이 아닌 그냥 '평균'이란 단어가 나온다면, 아직 어떤 기준을 사용할지 명확히 정해지지 않았다는 것이므로 생략하고 보시면 됩니다.

## 문법

정상적인 경우 HTTP 상태 코드는 200 OK로 응답해야 하지만, 사용자의 요청에 따라 다른 코드로 응답해야 할 수 있습니다. 목록 중간중간에 그래야 하는 상황들을 명시해 두었으며, 각 상태 코드의 의미는 다음과 같습니다.

- 200 OK: 정상적으로 요청이 실행되었고, 서버가 적절한 응답을 돌려줄 수 있습니다.
- 400 Bad Request: 사용자가 사이트에서 정상적으로는 제출할 수 없는 요청을 한 경우입니다.
  - 달리 말해, 프론트 개발자 역시 **해당 경우를 제출할 수 없도록 처리**해야 합니다.
- 401 Unauthorized: 사용자가 로그인 없이 요청을 한 경우입니다.
- 403 Forbidden: 사용자에게 권한이 허락되지 않은 요청을 한 경우입니다.
- 404 Not Found: 요청은 올바르지만, 서버에 사용자가 찾는 것이 존재하지 않는 경우입니다.
- 409 Conflict: 요청은 올바르지만, 서버에 이미 사용자가 추가하려는 것이 존재해 추가가 불가능한 경우입니다.
- 422 Unprocessable Entity: 요청은 올바르지만, 해당 요청은 서버에서 처리할 수 없음(혹은, 처리하지 않을 것임)을 뜻합니다.
- 429 Too Many Requests: 사용자에게 주어진 요청량을 초과한 경우입니다.
- 500 Internal Server Error: 요청은 올바르지만, 서버에서 해당 요청을 처리하는데 실패한 경우입니다.

### 문제 검색 쿼리

- 400: 길이가 256자 이상.
- 입력은 유니코드 범위 내에서 주어지며, 파싱되어야 합니다.
- 기본적으로 입력은 공백을 기준으로 끊어 구분됩니다.
  - 앞이나 뒤에 붙은 공백들은 삭제합니다. (trim)
  - 연속한 공백들은 하나로 취급합니다.
  - 후술하겠지만, 쌍따옴표 안에 있는 공백은 __구분자가 아닙니다__.
    - 따라서, 연속한 공백 역시 __하나로 취급하지 않습니다__.
- 기본적으로 주어진 검색어를 모두 만족시키는(교집합) 문제들을 구합니다.
- 각 검색어는 `!` 또는`~` 또는 `-` 로 시작할 수 있습니다. 셋 모두 해당 검색어에 맞지 않는(여집합) 문제들을 의미합니다.
- `1` 부터 `30` 까지의 수는 해당 난이도의 문제를 의미합니다.
  - 두 수가 온점 두 개로 연결되어 있다면, 범위 쿼리를 의미합니다.
    - 예시: `7..24` 는 난이도가 7 이상 24 이하인 문제를 의미합니다.
    - 참고: `start..end` 에서 `start` = `end` 이면, 범위 쿼리가 아닐 때와 동일한 성능이어야 합니다.
    - `start` > `end`일 경우 포함되는 문제는 없습니다.
  - 각 수가 `0` 이하 혹은 `30` 초과일 경우, 각각 1과 30으로 맞춥니다 (clamp).
    - 참고: 큰 수(예를 들면 100자리 이상)가 들어올 경우에도, 프로그램은 정상적으로 해당 작업을 처리해야 합니다.
- 쌍따옴표로 묶인 단어들은 해당 문자열이 제목에 포함된 문제를 의미합니다.
  - 위에서도 말했듯이, 공백이 있어도 하나의 검색어(제목 쿼리)로 취급합니다.
  - 백슬래시, 즉 `\` 가 발견되면 직후에 오는 문자를 하나의 문자로 취급합니다.
    - 예시: `"A \B\n\ \"\\\C"` 는 `A Bn "\C` 가 제목에 포함된 문제를 의미합니다.
- `@` 로 시작하는 검색어는 해당 유저가 푼 문제를 의미합니다.
  - 참고: 만약 `@` 만 단독으로 있는, 즉 뒤에 아무 글자도 이어지지 않는다면 본인이 푼 문제를 의미합니다.
- 위 조건들에 포함되지 않는 모든 검색어들은 해당 태그가 포함된 문제를 의미합니다.
  - 태그에는 문제 분류(web, pwn, crypto 등)가 포함될 수 있습니다.

### 정렬 기준

- 입력은 `_` 를 기준으로 끊어 구분합니다.
  - 예외: 끊었을 때 두 단어가 아니라면, 잘못된 쿼리입니다.
- 첫 번째 단어는 각 엔드포인트에 명시된 값들 중 포함되어 있어야 하며, 각 값에 대한 행동이 명시되어 있지 않고 해당 값에 대한 정렬 기준을 명확하게 알려져 있다면 해당 기준을 따릅니다.
  - 예시: `GET /problems` 에서 `id_asc` 는 `id` 를 기준으로 오름차순 정렬된 문제의 목록을 기준으로 작업을 수행해야 합니다.
  - 400: 명시된 값에 없는 단어인 경우.
- 두 번째 단어는 오름차순을 뜻하는 `asc`, 혹은 내림차순을 뜻하는 `desc` 입니다.
  - 400: `asc` 혹은 `desc` 가 아닌 경우.

### 페이지

- 한 페이지는 별도로 명시하지 않는 경우 30개입니다.
- 페이지는 1부터 시작합니다.
  - 400: 페이지가 `0`.
  - 400: 숫자 외의 다른 문자(`-`, `+`, `.` 포함)가 있는 경우.
  - 400: 해당 페이지가 존재하지 않는(범위에 포함된 결과가 0개) 경우.
    - 참고: 큰 수(예를 들면 100자리 이상)가 들어올 경우에도, 프로그램은 정상적으로 해당 쿼리가 잘못되었음을 판별해야 합니다.

## 자료형

### 기본 타입

- 배열: 가변 길이 배열을 의미합니다.
  - C++, Rust 등에선 벡터라는 이름으로 구현되어 있습니다.
- 집합: 중복이 없어야 합니다. 값이 정렬된 배열, 혹은 트리나 해시로 구성된 자료구조를 사용해야 합니다.
  - 전자는 빠르고 작으며, 실제 상황에서 n이 큰 경우는 적기 때문에 권장됩니다.
  - 후자는 느리고 크지만 시간복잡도가 보장되며, n이 커질 수 있다고 명시된 경우에만 사용하기를 권장합니다.
- 비트 집합: 위의 집합과는 관계 없습니다. 고정된 크기를 지니며, 8개의 비트 당 1바이트를 소모해야 합니다.
  - 크기가 64 이하라면, 64비트 부호 없는 정수 등으로 구현할 수 있습니다.
  - C++에는 bitset이란 이름으로 구현되어 있습니다.
  - Rust에는 BitSet이란 자료구조가 있지만, 고정 크기가 아니기 때문에 사용을 고민해보아야 합니다.

### 사용자

- uid: 사용자의 고유 번호입니다. 4바이트의 음수가 아닌 정수입니다.
  - 각 유저는 가입한 순서대로 번호를 부여받습니다. 처음 가입한 사용자는 1번입니다.
- username: 사용자의 핸들(핸들)입니다. 256바이트 이하의 문자열입니다.
- email: 사용자의 이메일입니다. 256바이트 이하의 문자열입니다.
  - Rust에서 이메일 형식 검증을 지원하는 라이브러리로 [validator](https://docs.rs/validator/0.13.0/validator/)를 권장합니다.
- password: 사용자의 비밀번호입니다. 256바이트 이하의 Argon2id 해시입니다.
  - Rust에서 Argon2 해시 처리를 지원하는 라이브러리로 [sodiumoxide](https://github.com/sodiumoxide/sodiumoxide)를 권장합니다.
- problems: 사용자가 푼 문제의 목록입니다. `submission` 관계로 표현됩니다.
- solves: 사용자가 푼 문제 개수입니다. 4바이트의 음수가 아닌 정수입니다.
- exp: 사용자의 분야별 경험치 합계입니다. 크기가 6인 8바이트 정수 배열입니다.
- groups: 사용자가 속한 그룹의 목록입니다. `group` 관계로 표현됩니다.
- friends: 사용자가 친구로 설정해둔 사람의 목록입니다. `friend` 관계로 표현됩니다.
- achievements: 사용자가 달성한 업적의 목록입니다. 크기가 256인 비트 집합입니다.
- favorite_achievement: 사용자가 대표로 표시하길 원하는 업적의 번호입니다. achievements의 크기 미만의 값을 저장할 수 있는 음수가 아닌 정수입니다.
- settings: 사용자의 개인 설정입니다. 65536바이트 이하의 JSON 문자열입니다.
- profile_image: 사용자의 프로필 사진 경로입니다. 256바이트 이하의 문자열입니다.
- profile_background: 사용자의 프로필 배경 사진 경로입니다. 256바이트 이하의 문자열입니다.

### 그룹

- users: 해당 그룹에 속한 사람들의 목록입니다. `group` 관계로 표현됩니다.

각 사용자는 여러 그룹에 속할 수 있습니다.

특수한 그룹으로 admin과 everyone, creator가 있습니다. admin은 거의 모든 권한이 허락되며, everyone은 가장 적은 권한이 허락됩니다. 관리자를 포함해 모든 사용자는 everyone 그룹에 속해 있습니다. creator는 문제를 만들 수 있습니다.

### 친구

- from: 사용자의 uid입니다.
- to: 사용자가 친구로 등록한 대상의 uid입니다.

### 문제

- id: 문제의 고유 번호입니다. 4바이트의 0이상의 정수입니다.
  - 각 문제는 추가된 순서대로 번호를 부여받습니다. 처음 추가된 문제는 1번입니다.
- level: 문제의 분야별 난이도입니다. 크기가 6인 0 이상 30 이하의 정수 배열입니다.
  - 각 분야의 난이도가 0이라면, 문제가 해당 분야에 속하지 않음을 의미합니다.
- title: 문제의 제목입니다. 256바이트 이하의 문자열입니다.
- source: 문제의 출처입니다. 256바이트 이하의 문자열입니다.
- flag: 문제의 답안입니다. 1024바이트 이하의 문자열입니다.
  - `/` 로 시작하면(예를 들면 `/.+/gmi`) 정규식, 아니면 일반 문자열입니다.
- content: 문제의 설명(디스크립션)입니다. 65536바이트 이하의 문자열입니다.
  - 마크다운 형식입니다.
- allowlist: 문제를 보고 제출할 수 있는 그룹 및 사용자의 목록입니다.
  - `@` 로 시작하면 사용자, 아니면 그룹입니다.
- creators: 문제를 편집하거나 공개 범위를 수정할 수 있는 그룹 및 사용자의 목록입니다.
- solvers: 문제를 푼 사용자의 목록입니다. **submission** 관계로 표현됩니다.
- solves: 문제를 푼 사용자의 수입니다. 4바이트의 0이상의 정수입니다.
- comments: 문제에 대한 사용자 평가, 기여 목록입니다. **submission** 관계로 표현됩니다.

### 제출

- id: 해결된 문제의 id입니다.
- user: 문제를 푼 사용자의 uid입니다.
- time: 사용자가 해당 문제를 푼 시간입니다. 8바이트 UNIX timestamp입니다.
- level: 사용자가 평가한 해당 문제의 분야별 난이도입니다. 크기가 6인 0 이상 30 이하의 정수 배열입니다.
- comment_time: 사용자가 해당 문제에 대한 평가를 마지막으로 수정한 시간입니다. 8바이트 UNIX timestamp입니다.
- comment: 사용자가 해당 문제에 대해 적은 평가입니다. 65536바이트 이하의 문자열입니다.

제출이 추가 혹은 갱신될 경우, 다음 의사코드와 동일한 일을 수행하는 [TRIGGER](https://www.postgresql.org/docs/current/sql-createtrigger.html)를 작동시켜야 합니다.

```cpp
// 입력: uid, id, level
auto& p = problems[id];
auto old_plevel = p.level;
p.solves += 1;
p.level += (level - p.level) / p.solves;
users[uid].exp += 1 << round(old_plevel);

auto diff = (1 << round(p.level)) - (1 << round(old_plevel));
if (diff != 0)
	for (auto& user : p.solvers)
		user.exp += diff;
```

### 세션 ID

[암호학적으로 안전하게 랜덤으로 생성](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator)된 32바이트의 바이너리 문자열입니다. **중복**된 세션 ID를 **생성해서는 안 되며**, 사용자와 통신할 때는 base64로 변환하여 세션 ID를 주고받습니다.

안전한 랜덤 생성을 지원하는 라이브러리로 [sodiumoxide](https://github.com/sodiumoxide/sodiumoxide)를 권장합니다.

사용자는 X-Session-Id 헤더에 세션 ID를 넣어 응답을 전송합니다. 이는 추후 Autorhization 헤더 등을 사용하는 것으로 변경될 수 있습니다.

서버는 X-Session-Id가 다음과 같은 경우 즉시 상태 코드를 401로 설정하고 빈 문자열을 반환합니다.

- 올바른 base64 문자열이 아닌 경우.
- base64를 디코드했을 때 32바이트가 아닌 경우.
- 해당 세션이 DB에 존재하지 않는 경우.

### 이메일 인증 코드

[암호학적으로 안전하게 랜덤으로 생성](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator)된 대문자 + 숫자로 이루어진 길이 6의 문자열입니다. 세션 ID와는 달리, 이메일마다 코드를 가지고 있기 때문에 중복이 생겨도 무방합니다.

각 이메일은 최대 하나의 코드를 가질 수 있습니다. 자세한 설명은 `POST /authenticate_email` 를 참고하세요.

## 목록

CTF 아카이브에서 사용자의 입력은 다음 세 가지 중 하나의 형태로 들어옵니다.

1. 주소에서 /로 구분된 단어들 중 :로 시작하는 것

  - 예시: `GET /dragon/:dragon_id/likes/:category` 에서 `dragon_id` 와 `category` 는 1번에 해당하는 입력입니다.

2. HTTP 메서드가 GET / DELETE: 주소에서 ? 뒤에 오는 것들, 즉 query string

  - 예시: `GET /snake/:snake_id/:snake_type?start=5&limit=60` 에서 `start` 와 `limit` 는 2번에 해당하는 입력입니다.

3. HTTP 메서드가 POST / PUT: HTTP Body. JSON 형태

  - 예시: `POST /write/:post_id` 주소로 body가 `{"title":"asdf","content":"asdf"}` 인 요청이 들어왔을 때 `title` 과 `content` 는 3번에 해당하는 입력입니다.

1번은 제목(주소)에 명시적으로 적혀 있습니다. 2번과 3번은 제목에 적기엔 너무 많거나 지저분해져 생략합니다. 즉, 1번에 해당하지 않는 입력은 2번 혹은 3번으로 들어온다고 생각해 주세요. 또한 HTTP 규칙 상 각 요청에서 1번 형태가 아닌 입력은 반드시 2번이나 3번 중 하나의 형태로만 들어옵니다.

3번에 해당하는 경우(즉, HTTP 메서드가 POST인 경우), **Content-Type** 헤더는 반드시 **application/json**이어야 합니다. **아니라면, 상태 코드는 400이며 빈 문자열을 반환하여야 합니다**.

### PUT /problems

요청한 사용자가 문제 생성 권한이 있는 경우, 주어진 문제를 새로 추가합니다. 이미 해당 문제가 존재한다면, 아무 일도 하지 않습니다. 문제 생성 권한이 있다는 것은, 요청한 사용자의 groups에 admin과 creator 중 하나 이상이 포함된 경우입니다.

- title: 문제의 제목입니다.
- source: 문제에 제출할 출처입니다.
- flag: 문제의 답입니다.
- content: 문제의 내용(디스크립션)입니다.

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다.

- id: 추가된 문제의 id입니다.

실패 시 처리는 다음과 같습니다.

- 401: 로그인을 하지 않은 경우입니다. 반환값은 빈 문자열입니다.
- 403: 요청한 사용자가 문제 생성 권한이 없는 경우입니다. 반환값은 빈 문자열입니다.

### GET /problems

요청한 사용자에게 공개된 문제들 중, 주어진 조건에 맞는 문제의 목록을 반환합니다. 공개되었다는 것은, 요청한 사용자의 groups에 admin이 없으며, 문제의 allowlist와의 교집합이 공집합이 아니라는 의미입니다.

- query: 문제 검색 쿼리입니다.
- sort: 문제를 정렬할 기준입니다.
- page: 페이지의 번호입니다.

정렬 기준은 다음과 같습니다.

- id
- level
- solves

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다.

- count: query를 만족하며 해당 사용자에게 공개된 문제의 개수입니다. sort 혹은 page에 영향을 받지 __않습니다__.
- problems: 문제 정보들을 sort에 따라 정렬했을 때, [25 * (page - 1), 25 * page) 구간 배열입니다. 문제 정보는 다음과 같은 객체입니다.
  - { id, level, title, source, solves }

실패 시 처리는 다음과 같습니다.

- 400: 쿼리가 잘못된 경우입니다. 반환값은 `{"count":0,"problems":[]}` 입니다.

### DELETE /problems/:problem

요청한 사용자가 편집 권한이 있는 경우, 해당 문제를 삭제합니다. 편집 권한이 있다는 것은, 요청한 사용자의 groups와 문제의 creators의 교집합이 공집합이 아니라는 의미입니다.

- problem: 문제의 id입니다.

성공 시 반환값은 빈 문자열입니다.

실패 시 처리는 다음과 같습니다.

- 401: 로그인을 하지 않은 경우입니다. 반환값은 빈 문자열입니다.
- 403: 요청한 사용자가 편집 권한이 없는 경우입니다. 반환값은 빈 문자열입니다.
- 404: 문제가 존재하지 않는 경우입니다. 반환값은 빈 문자열입니다.

### GET /problems/:problem

요청한 사용자에게 공개된 문제인 경우, 해당 문제를 반환합니다. 공개되었다는 것의 의미는 `GET /problems` 와 동일합니다.

- problem: 문제의 id입니다.

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다.

- { level, title, source, content, solves }

실패 시 처리는 다음과 같습니다.

- 400: problem이 올바르지 않은 id인 경우입니다. 반환값은 빈 문자열입니다.
- 403: 요청한 사용자에게 공개되지 않은 문제인 경우입니다. 반환값은 빈 문자열입니다.
- 404: 문제가 존재하지 않는 경우입니다. 반환값은 빈 문자열입니다.

### GET /problems/:problem/content

요청한 사용자에게 공개된 문제인 경우, 해당 문제의 설명(디스크립션)을 반환합니다. 공개되었다는 것의 의미는 `GET /problems` 와 동일합니다

- problem: 문제의 id입니다.

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다.

- { content }

실패 시 처리는 다음과 같습니다.

- 400: problem이 올바르지 않은 id인 경우입니다. 반환값은 빈 문자열입니다.
- 403: 요청한 사용자에게 공개되지 않은 문제인 경우입니다. 반환값은 빈 문자열입니다.
- 404: 문제가 존재하지 않는 경우입니다. 반환값은 빈 문자열입니다.

### GET /problems/:problem/solvers

요청한 사용자에게 공개된 문제인 경우, 해당 문제를 푼 사람의 목록을 반환합니다. 공개되었다는 것의 의미는 `GET /problems` 와 동일합니다

- problem: 문제의 id입니다.
- sort: 사용자를 정렬할 기준입니다.
- page: 페이지의 번호입니다.

정렬 기준은 다음과 같습니다.

- time

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다.

- count: 해당 문제를 푼 사람의 수입니다. sort 혹은 page에 영향을 받지 __않습니다__.
- solvers: 해당 문제를 sort에 따라 정렬했을 때, [25 * (page - 1), 25 * page) 구간 배열입니다. 문제 정보는 다음과 같은 객체입니다.
  - { id, level, title, source, solves }

실패 시 처리는 다음과 같습니다.

- 400: problem이 올바르지 않은 id인 경우입니다. 반환값은 빈 문자열입니다.
- 403: 요청한 사용자에게 공개되지 않은 문제인 경우입니다. 반환값은 빈 문자열입니다.
- 404: 문제가 존재하지 않는 경우입니다. 반환값은 빈 문자열입니다.

### GET /problems/:problem/flags/:flag

요청한 사용자에게 공개된 문제인 경우, 주어진 답이 맞는지 확인해 줍니다. 답이 맞는지 판별하는 것 외에 아무 일도 하지 않습니다.

- problem: 제출할 문제의 id입니다.
- flag: 문제에 제출할 답안입니다.

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다.

- correct: 답이 맞는지를 의미하는 boolean 값입니다.

실패 시 처리는 다음과 같습니다.

- 400: problem이 올바르지 않은 id인 경우입니다. 반환값은 빈 문자열입니다.
- 401: 로그인을 하지 않은 경우입니다. 반환값은 빈 문자열입니다.
- 403: 요청한 사용자에게 공개되지 않은 문제인 경우입니다. 반환값은 빈 문자열입니다.
- 404: 문제가 존재하지 않는 경우입니다. 반환값은 빈 문자열입니다.

### PUT /submissions/:problem

요청한 사용자에게 공개된 문제인 경우, 주어진 문제에 답을 제출합니다. 답이 틀린 경우 별도로 아무 일도 하지 않으며, 맞다면 DB에 제출을 추가합니다.

- problem: 제출할 문제의 id입니다.
- flag: 문제에 제출할 답안입니다.
- level: 사용자가 평가한 해당 문제의 분야별 난이도입니다.
- comment: 사용자가 해당 문제에 대해 적은 평가입니다.

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다.

- time: 요청을 받은 직후의 서버 시간, 즉 문제를 푼 시간입니다. 8바이트 UNIX timestamp입니다.
- correct: 답이 맞는지를 의미하는 boolean 값입니다.

실패 시 처리는 다음과 같습니다.

- 400: problem이 올바르지 않은 id인 경우입니다. 반환값은 빈 문자열입니다.
- 401: 로그인을 하지 않은 경우입니다. 반환값은 빈 문자열입니다.
- 403: 요청한 사용자에게 공개되지 않은 문제인 경우입니다. 반환값은 빈 문자열입니다.
- 404: 문제가 존재하지 않는 경우입니다. 반환값은 빈 문자열입니다.

### POST /submissions/:problem

요청한 사용자에게 공개된 문제인 경우, 주어진 문제에 제출한 기여를 수정합니다. 사용자가 해당 문제에 제출하여 맞은 적이 없는 경우 별도로 아무 일도 하지 않으며, 있다면 DB의 제출을 갱신합니다.

- problem: 제출할 문제의 id입니다.
- flag: 문제에 제출할 답안입니다.
- level: 사용자가 평가한 해당 문제의 분야별 난이도입니다.
- comment: 사용자가 해당 문제에 대해 적은 평가입니다.

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다.

- time: 요청을 받은 직후의 서버 시간, 즉 문제를 푼 시간입니다. 8바이트 UNIX timestamp입니다.
- correct: 답이 맞는지를 의미하는 boolean 값입니다.

실패 시 처리는 다음과 같습니다.

- 400: problem이 올바르지 않은 id인 경우입니다. 반환값은 빈 문자열입니다.
- 401: 로그인을 하지 않은 경우입니다. 반환값은 빈 문자열입니다.
- 403: 요청한 사용자에게 공개되지 않은 문제인 경우입니다. 반환값은 빈 문자열입니다.
- 404: 문제가 존재하지 않는 경우입니다. 반환값은 빈 문자열입니다.

### GET /users

주어진 조건에 맞는 사용자의 목록을 반환합니다.

- query: 검색어입니다.
- sort: 문제를 정렬할 기준입니다.
- page: 페이지의 번호입니다.

정렬 기준은 다음과 같습니다.

- level
- solves

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다.

- count: username에 query를 포함하는 사용자의 수입니다. sort 혹은 page에 영향을 받지 __않습니다__.
- users: username에 query를 포함하는 사용자들의 정보를 sort에 따라 정렬했을 때, [50 * (page - 1), 50 * page) 구간 배열입니다. 사용자 정보는 다음과 같은 객체입니다.
  - { username, solves, exp, favorite_achievement, profileImage, profileBackground }

### GET /users/:user

해당 사용자를 반환합니다.

- user: 사용자의 username입니다.

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다.

- { username, solves, exp, achievements, favorite_achievement, profileImage, profileBackground }

실패 시 처리는 다음과 같습니다.

- 404: 해당 사용자가 존재하지 않는 경우입니다. 반환값은 빈 문자열입니다.

### GET /users/-

해당 요청을 한 사용자 본인의 정보를 반환합니다.

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다.

- { username, problems, solves, exp, friends, achievements, favorite_achievement, settings, profileImage, profileBackground }

실패 시 처리는 다음과 같습니다.

- 401: 로그인을 하지 않은 경우입니다. 반환값은 빈 문자열입니다.

### POST /authenticate_email

사용자의 이메일을 받고, 올바른 이메일인지 확인한 후 해당 주소로 인증 코드를 전송합니다. 현재는 일부 알려진 도메인의 이메일만 허용합니다.

IP와 이메일 각각에 요청 횟수에 제한이 있으며, 둘 중 하나라도 요청 횟수가 5번을 초과한다면 즉시 429 상태 코드를 반환합니다.

해당 이메일에 이미 인증 코드가 DB에 있는 경우(즉, 사용자가 인증을 재요청한 경우) 새로 생성한 인증 코드로 대체하고 다시 전송합니다.

요청 횟수 제한과 이메일 인증 코드 관련 데이터들은 생성되고 하루가 지나면 완전히 삭제됩니다. 구현에 따라 '인증 데이터가 생성되고 하루가 지나면 삭제'가 아닌, '하루마다 인증 데이터들을 모두 삭제'하여도 됩니다. 단, 이 경우 사용자가 가장 적은 시간대에만 해당 작업을 시행하는 것이 좋습니다.

- email: 사용자의 이메일입니다.

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다.

- type: 응답의 타입입니다. 기본적으로 `"OK"` 입니다.

실패 시 처리는 다음과 같습니다.

- 400: 이메일이 잘못된 형식인 경우입니다. 반환값은 빈 문자열입니다.
- 400: 사용할 수 없는 이메일입니다. 반환값은 `{"type":"DEA"}` 입니다.
  - 최소한 [disposable-email-domains](https://github.com/disposable-email-domains/disposable-email-domains)의 blocklist 목록에 있는 주소들은 모두 차단해야 합니다.
  - [Kickbox](https://open.kickbox.io/) 혹은 [Debounce](https://debounce.io/free-disposable-check-api/) 등의 API를 사용할 수도 있습니다.
  - 현재는 특정 이메일만 허용하기 때문에, 위를 구현할 필요는 없습니다.
- 409: 다른 사람이 사용중인 이메일인 경우입니다. 반환값은 `{"type":"USED"}` 입니다.
- 429: 인증 요청 횟수가 제한을 초과한 경우입니다. 반환값은 `{"type":"EXCEEDED"}` 입니다.
- 500: 해당 이메일로 코드를 전송하는데 실패한 경우입니다. 반환값은 `{"type":"FAILED"}` 입니다.

### POST /register

사용자의 정보를 받아 가입시킵니다. 성공적으로 가입한 후에는, `POST /login` 을 실행시킨 것과 동일한 작업을 수행해야 합니다.

만약 성공적으로 가입이 된 경우, DB에서 이메일 인증 코드 관련 데이터들을 모두 제거합니다.

- code: 사용자에게 전송한 가입 인증 코드입니다.
- email: 사용자의 이메일입니다.
- username: 사용자의 핸들입니다.
- password: 사용자의 비밀번호입니다.

성공 시 `POST /login` 과 동일한 형식의 결과를 반환합니다.

실패 시 처리는 다음과 같습니다.

- 400: 해당 이메일이 존재하지 않거나, 해당 이메일로 `POST /authenticate_email` 을 통해 전송한 코드와 주어진 코드가 일치하지 않는 경우입니다. 반환값은 빈 문자열입니다.
- 409: 다른 사람이 사용중인 핸들일 경우입니다. 반환값은 `{"type":"USED"}` 입니다.

### POST /login

사용자의 이메일과 비밀번호 혹은 핸들과 비밀번호를 받아 로그인시킵니다.

- id: 사용자의 이메일 혹은 username입니다.
- password: 사용자의 비밀번호입니다.

성공 시 반환값은 JSON이며, 다음과 같은 객체입니다. *더 추가될 가능성이 높습니다.*

- type: 응답의 타입입니다. 기본적으로 `"OK"` 입니다.
- sessionid: 세션 ID를 base64로 표현한 값입니다.
- username: 사용자의 핸들입니다.
- settings: 사용자의 개인 설정입니다.

실패 시 처리는 다음과 같습니다.

- 400: id가 이메일이며, 이메일이 잘못된 형식인 경우입니다. 반환값은 빈 문자열입니다.
- 401: 해당 이메일 / 핸들이 없거나, 비밀번호가 맞지 않아 로그인에 실패한 경우입니다. 반환값은 `{"type":"WRONG"}` 입니다.

## 테스트

### 문제

문제의 개수가 테스트를 하기에 부족하거나(1만개 이하), 혹은 실제 문제들을 불러오기 어려울 경우, 임의의 랜덤한 값으로 채워넣어 테스트하는 것을 권장합니다. 아래에서는 타입별 권장 사항을 서술합니다.

- 고유하지 않은 정수: 제한 내의 랜덤 수를 생성합니다.
- 256바이트 미만의 문자열: 8바이트의 랜덤 문자열을 생성합니다. charset은 printable ascii입니다.
- 65536바이트 미만의 문자열: 2048바이트의 랜덤 문자열을 생성합니다. charset은 printable ascii입니다.
